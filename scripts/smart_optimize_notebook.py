#!/usr/bin/env python3
"""
Skrypt do notebooka - Optymalizacja tras tramwajowych w Krakowie
Nowy, inteligentny algorytm zgodny z wymaganiami hackathonu.
"""

import sys
import os
import warnings
warnings.filterwarnings('ignore')

# Dodaj ≈õcie≈ºkƒô do modu≈Ç√≥w
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import geopandas as gpd
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import folium
from folium import plugins
import logging
from typing import List, Tuple, Dict

# Import nowego optymalizatora
from src.optimization.smart_route_optimizer import SmartRouteOptimizer, RouteConstraints
from src.visualization.route_visualizer import RouteVisualizer

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def load_krakow_data(data_dir: str = None) -> Tuple[gpd.GeoDataFrame, gpd.GeoDataFrame, gpd.GeoDataFrame, gpd.GeoDataFrame]:
    """
    Wczytuje dane o Krakowie z plik√≥w GeoJSON.
    
    Args:
        data_dir: ≈öcie≈ºka do katalogu z danymi (domy≈õlnie ../data)
        
    Returns:
        Tuple z DataFrames: buildings, streets, stops, lines
    """
    if data_dir is None:
        data_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'data')
    
    print("üóÇÔ∏è Wczytywanie danych o Krakowie...")
    
    # ≈öcie≈ºki do plik√≥w
    files = {
        'buildings': os.path.join(data_dir, 'buildings.geojson'),
        'streets': os.path.join(data_dir, 'streets.geojson'),
        'stops': os.path.join(data_dir, 'stops.geojson'),
        'lines': os.path.join(data_dir, 'lines.geojson')
    }
    
    # Sprawd≈∫ czy pliki istniejƒÖ
    for name, path in files.items():
        if not os.path.exists(path):
            raise FileNotFoundError(f"Nie znaleziono pliku: {path}")
    
    # Wczytaj dane
    buildings_df = gpd.read_file(files['buildings'])
    streets_df = gpd.read_file(files['streets'])
    stops_df = gpd.read_file(files['stops'])
    lines_df = gpd.read_file(files['lines'])
    
    print(f"‚úÖ Wczytano dane:")
    print(f"   üìò Budynki: {len(buildings_df):,}")
    print(f"   üõ£Ô∏è Ulice: {len(streets_df):,}")
    print(f"   üöè Przystanki: {len(stops_df):,}")
    print(f"   üöä Linie tramwajowe: {len(lines_df):,}")
    
    return buildings_df, streets_df, stops_df, lines_df

def setup_optimizer(buildings_df: gpd.GeoDataFrame, 
                   streets_df: gpd.GeoDataFrame, 
                   stops_df: gpd.GeoDataFrame, 
                   lines_df: gpd.GeoDataFrame) -> SmartRouteOptimizer:
    """
    Konfiguruje optymalizator tras zgodnie z wymaganiami hackathonu.
    
    Returns:
        Skonfigurowany SmartRouteOptimizer
    """
    print("‚öôÔ∏è Konfiguracja optymalizatora...")
    
    # Ograniczenia zgodne z wymaganiami hackathonu
    constraints = RouteConstraints(
        min_distance_between_stops=350,    # min 350m miƒôdzy przystankami
        max_distance_between_stops=700,    # max 700m miƒôdzy przystankami  
        min_total_length=1500,             # min 1.5km d≈Çugo≈õƒá trasy
        max_total_length=15000,            # max 15km d≈Çugo≈õƒá trasy
        min_route_stops=4,                 # min 4 przystanki
        max_route_stops=15,                # max 15 przystank√≥w
        min_distance_from_buildings=5.0,   # 5m od budynk√≥w
        buffer_around_existing_lines=50.0  # 50m od istniejƒÖcych linii
    )
    
    # Inicjalizuj optymalizator
    optimizer = SmartRouteOptimizer(
        buildings_df=buildings_df,
        streets_df=streets_df,
        stops_df=stops_df,
        lines_df=lines_df,
        constraints=constraints
    )
    
    print("‚úÖ Optymalizator skonfigurowany zgodnie z wymaganiami hackathonu")
    return optimizer

def optimize_tram_routes(optimizer: SmartRouteOptimizer, 
                        num_routes: int = 3) -> List[Tuple[List[Tuple[float, float]], float]]:
    """
    Optymalizuje trasy tramwajowe zgodnie z wymaganiami:
    1. Maksymalizuje pokrycie obszar√≥w o du≈ºej gƒôsto≈õci zabudowy
    2. Maksymalizuje dystans miƒôdzy przystankami  
    3. Minimalizuje liczbƒô zakrƒôt√≥w
    4. Unika kolizji z budynkami
    5. Nie pokrywa siƒô z istniejƒÖcymi liniami
    
    Args:
        optimizer: Skonfigurowany optymalizator
        num_routes: Liczba tras do optymalizacji
        
    Returns:
        Lista par (trasa, ocena)
    """
    print(f"üöä Rozpoczynam optymalizacjƒô {num_routes} tras tramwajowych...")
    print("üìã Wymagania:")
    print("   ‚úì Maksymalizacja pokrycia obszar√≥w o du≈ºej gƒôsto≈õci zabudowy")
    print("   ‚úì Maksymalizacja dystansu miƒôdzy przystankami")
    print("   ‚úì Minimalizacja liczby zakrƒôt√≥w")
    print("   ‚úì Unikanie kolizji z budynkami")
    print("   ‚úì Brak pokrywania z istniejƒÖcymi liniami")
    print("   ‚úì Lokalne budowanie tras (bez 'skakania')")
    
    # Uruchom optymalizacjƒô
    optimized_routes = optimizer.optimize_routes(
        num_routes=num_routes,
        max_iterations=50  # Zmniejszone dla szybszego dzia≈Çania w notebooku
    )
    
    print(f"\nüéâ Optymalizacja zako≈Ñczona!")
    print(f"‚úÖ Znaleziono {len(optimized_routes)}/{num_routes} tras")
    
    # Poka≈º statystyki
    stats = optimizer.get_optimization_stats()
    print(f"\nüìä Statystyki uczenia siƒô:")
    print(f"   üß† Zapamiƒôtane trasy: {stats['successful_routes']}")
    print(f"   üîó Nauczone po≈ÇƒÖczenia: {stats['learned_connections']}")
    print(f"   ‚ùå Z≈Çe obszary: {stats['bad_areas']}")
    
    return optimized_routes

def analyze_routes(routes: List[Tuple[List[Tuple[float, float]], float]], 
                  optimizer: SmartRouteOptimizer) -> None:
    """
    Analizuje znalezione trasy i pokazuje szczeg√≥≈Çowe informacje.
    
    Args:
        routes: Lista znalezionych tras
        optimizer: Optymalizator (do oblicze≈Ñ)
    """
    print(f"\nüìã ANALIZA ZNALEZIONYCH TRAS")
    print("=" * 50)
    
    for i, (route, score) in enumerate(routes, 1):
        print(f"\nüöä TRASA {i}:")
        print(f"   üìä Ocena: {score:.1f}/100")
        print(f"   üöè Liczba przystank√≥w: {len(route)}")
        
        # Oblicz d≈Çugo≈õƒá trasy
        total_length = 0
        for j in range(len(route) - 1):
            dist = optimizer._calculate_distance_wgs84(route[j], route[j + 1])
            total_length += dist
        
        print(f"   üìè D≈Çugo≈õƒá trasy: {total_length/1000:.1f} km")
        print(f"   üó∫Ô∏è Zakres: lat {min(p[0] for p in route):.4f}-{max(p[0] for p in route):.4f}")
        print(f"           lon {min(p[1] for p in route):.4f}-{max(p[1] for p in route):.4f}")
        
        # Sprawd≈∫ bezpiecze≈Ñstwo
        is_safe, safety_msg = optimizer.is_route_safe(route)
        safety_status = "‚úÖ BEZPIECZNA" if is_safe else "‚ùå PROBLEMY"
        print(f"   üîí Bezpiecze≈Ñstwo: {safety_status} - {safety_msg}")
        
        # Oce≈Ñ gƒôsto≈õƒá zabudowy
        density_scores = []
        for lat, lon in route:
            density = optimizer.density_calculator.calculate_density_at_point(lat, lon)
            density_scores.append(density)
        
        avg_density = np.mean(density_scores)
        print(f"   üèòÔ∏è ≈örednia gƒôsto≈õƒá zabudowy: {avg_density:.2f}")
        
        # Sprawd≈∫ odleg≈Ço≈õci miƒôdzy przystankami
        distances = []
        for j in range(len(route) - 1):
            dist = optimizer._calculate_distance_wgs84(route[j], route[j + 1])
            distances.append(dist)
        
        if distances:
            print(f"   üìê Odleg≈Ço≈õci: min {min(distances):.0f}m, "
                  f"max {max(distances):.0f}m, ≈õred {np.mean(distances):.0f}m")

def create_interactive_map(routes: List[Tuple[List[Tuple[float, float]], float]], 
                          buildings_df: gpd.GeoDataFrame,
                          stops_df: gpd.GeoDataFrame,
                          lines_df: gpd.GeoDataFrame = None) -> folium.Map:
    """
    Tworzy interaktywnƒÖ mapƒô z zoptymalizowanymi trasami.
    
    Args:
        routes: Lista znalezionych tras
        buildings_df: DataFrame z budynkami
        stops_df: DataFrame z przystankami  
        lines_df: DataFrame z istniejƒÖcymi liniami
        
    Returns:
        Interaktywna mapa Folium
    """
    print("üó∫Ô∏è Tworzenie interaktywnej mapy...")
    
    if not routes:
        print("‚ùå Brak tras do wizualizacji")
        return None
    
    # Centrum mapy - ≈õrednia z wszystkich tras
    all_points = []
    for route, _ in routes:
        all_points.extend(route)
    
    center_lat = np.mean([p[0] for p in all_points])
    center_lon = np.mean([p[1] for p in all_points])
    
    # Utw√≥rz mapƒô
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=12,
        tiles='OpenStreetMap'
    )
    
    # Kolory dla tras
    colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']
    
    # Dodaj istniejƒÖce linie tramwajowe (t≈Ço)
    if lines_df is not None:
        print("   Dodawanie istniejƒÖcych linii tramwajowych...")
        for _, line in lines_df.iterrows():
            if hasattr(line.geometry, 'coords'):
                coords = [(lat, lon) for lon, lat in line.geometry.coords]
                folium.PolyLine(
                    coords, 
                    color='gray', 
                    weight=2, 
                    opacity=0.5,
                    popup="IstniejƒÖca linia tramwajowa"
                ).add_to(m)
    
    # Dodaj przystanki (ma≈Çe kropki)
    print("   Dodawanie przystank√≥w...")
    for _, stop in stops_df.iterrows():
        folium.CircleMarker(
            location=[stop.geometry.y, stop.geometry.x],
            radius=2,
            color='lightgray',
            fill=True,
            fillOpacity=0.3,
            popup=f"Przystanek"
        ).add_to(m)
    
    # Dodaj nowe trasy
    print("   Dodawanie nowych zoptymalizowanych tras...")
    for i, (route, score) in enumerate(routes):
        color = colors[i % len(colors)]
        
        # Linia trasy
        folium.PolyLine(
            route, 
            color=color, 
            weight=4, 
            opacity=0.8,
            popup=f"Nowa trasa {i+1} (ocena: {score:.1f})"
        ).add_to(m)
        
        # Przystanki na trasie
        for j, (lat, lon) in enumerate(route):
            folium.CircleMarker(
                location=[lat, lon],
                radius=6,
                color=color,
                fill=True,
                fillColor=color,
                fillOpacity=0.8,
                popup=f"Trasa {i+1} - Przystanek {j+1}"
            ).add_to(m)
    
    # Dodaj legendƒô
    legend_html = '''
    <div style="position: fixed; 
                top: 10px; right: 10px; width: 200px; height: auto; 
                background-color: white; border:2px solid grey; z-index:9999; 
                font-size:14px; padding: 10px">
    <h4>Legenda</h4>
    <p><span style="color:gray;">‚óè</span> IstniejƒÖce linie</p>
    <p><span style="color:lightgray;">‚óè</span> Przystanki</p>
    <p><span style="color:red;">‚óè</span> Nowa trasa 1</p>
    <p><span style="color:blue;">‚óè</span> Nowa trasa 2</p>
    <p><span style="color:green;">‚óè</span> Nowa trasa 3</p>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))
    
    print("‚úÖ Mapa utworzona")
    return m

def save_results(routes: List[Tuple[List[Tuple[float, float]], float]], 
                output_dir: str = None) -> str:
    """
    Zapisuje wyniki optymalizacji do plik√≥w.
    
    Args:
        routes: Lista znalezionych tras
        output_dir: Katalog wyj≈õciowy (domy≈õlnie ../results)
        
    Returns:
        ≈öcie≈ºka do zapisanych plik√≥w
    """
    if output_dir is None:
        output_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'results')
    
    os.makedirs(output_dir, exist_ok=True)
    
    print(f"üíæ Zapisywanie wynik√≥w do {output_dir}...")
    
    # Zapisz jako CSV
    routes_data = []
    for i, (route, score) in enumerate(routes, 1):
        for j, (lat, lon) in enumerate(route):
            routes_data.append({
                'route_id': i,
                'stop_order': j + 1,
                'latitude': lat,
                'longitude': lon,
                'route_score': score
            })
    
    df = pd.DataFrame(routes_data)
    csv_path = os.path.join(output_dir, 'optimized_routes.csv')
    df.to_csv(csv_path, index=False)
    
    # Zapisz jako GeoJSON
    geometries = []
    for i, (route, score) in enumerate(routes, 1):
        from shapely.geometry import LineString
        line = LineString([(lon, lat) for lat, lon in route])
        geometries.append({
            'geometry': line,
            'route_id': i,
            'score': score,
            'num_stops': len(route)
        })
    
    if geometries:
        gdf = gpd.GeoDataFrame(geometries, crs='EPSG:4326')
        geojson_path = os.path.join(output_dir, 'optimized_routes.geojson')
        gdf.to_file(geojson_path, driver='GeoJSON')
    
    print(f"‚úÖ Zapisano:")
    print(f"   üìÑ CSV: {csv_path}")
    print(f"   üó∫Ô∏è GeoJSON: {geojson_path}")
    
    return output_dir

# G≈Å√ìWNA FUNKCJA DO URUCHOMIENIA W NOTEBOOKU
def run_tram_optimization(data_dir: str = None, 
                         num_routes: int = 3,
                         save_map: bool = True) -> Tuple[List, folium.Map]:
    """
    G≈Å√ìWNA FUNKCJA - uruchom pe≈ÇnƒÖ optymalizacjƒô tras tramwajowych.
    
    Args:
        data_dir: Katalog z danymi (domy≈õlnie ../data)
        num_routes: Liczba tras do optymalizacji (domy≈õlnie 3)
        save_map: Czy zapisaƒá mapƒô do pliku (domy≈õlnie True)
        
    Returns:
        Tuple (lista_tras, mapa_folium)
        
    U≈ºycie w notebooku:
        routes, map_viz = run_tram_optimization()
        map_viz  # wy≈õwietl mapƒô
    """
    print("üöä OPTYMALIZACJA TRAS TRAMWAJOWYCH W KRAKOWIE")
    print("=" * 60)
    print("üìã Zgodne z wymaganiami hackathonu:")
    print("   ‚úì Maksymalizacja gƒôsto≈õci zabudowy (300m radius)")
    print("   ‚úì Maksymalizacja dystansu miƒôdzy przystankami")  
    print("   ‚úì Unikanie kolizji z budynkami (5m buffer)")
    print("   ‚úì Brak pokrywania z istniejƒÖcymi liniami (50m buffer)")
    print("   ‚úì Lokalne budowanie tras bez 'skakania'")
    print("   ‚úì Algorytm z uczeniem siƒô")
    print("=" * 60)
    
    try:
        # 1. Wczytaj dane
        buildings_df, streets_df, stops_df, lines_df = load_krakow_data(data_dir)
        
        # 2. Skonfiguruj optymalizator
        optimizer = setup_optimizer(buildings_df, streets_df, stops_df, lines_df)
        
        # 3. Optymalizuj trasy
        routes = optimize_tram_routes(optimizer, num_routes)
        
        if not routes:
            print("‚ùå Nie znaleziono ≈ºadnych tras!")
            return [], None
        
        # 4. Analizuj wyniki
        analyze_routes(routes, optimizer)
        
        # 5. Utw√≥rz mapƒô
        interactive_map = create_interactive_map(routes, buildings_df, stops_df, lines_df)
        
        # 6. Zapisz wyniki
        results_dir = save_results(routes)
        
        # 7. Zapisz mapƒô je≈õli requested
        if save_map and interactive_map:
            map_path = os.path.join(results_dir, 'interactive_map.html')
            interactive_map.save(map_path)
            print(f"üó∫Ô∏è Mapa zapisana: {map_path}")
        
        print(f"\nüéâ OPTYMALIZACJA ZAKO≈ÉCZONA POMY≈öLNIE!")
        print(f"‚úÖ Znaleziono {len(routes)} tras spe≈ÇniajƒÖcych wszystkie wymagania")
        
        return routes, interactive_map
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas optymalizacji: {e}")
        import traceback
        traceback.print_exc()
        return [], None

if __name__ == "__main__":
    # Uruchomienie standalone
    routes, map_viz = run_tram_optimization(num_routes=3)
    if map_viz:
        print("Mapa zapisana jako 'interactive_map.html'") 